id: TIME_BASED_MYSQLI_POST
info:
  name: "Time based SQL injection test for MySQL DB for POST method APIs"
  description: "The Time-Based SQL Injection Test for MySQL DB for POST Method APIs involves injecting malicious SQL queries into POST request parameters with the goal of exploiting time delays in the database response. By crafting queries that intentionally cause time delays, attackers can infer the presence of a vulnerability based on the response time. This technique helps identify blind SQL injection vulnerabilities, where direct error messages are not returned, but the server’s response time can reveal valuable information about the database structure or the presence of SQL injection flaws. Proper input sanitization and the use of prepared statements are essential to prevent this type of attack."
  details: "The Time-Based SQL Injection Test for MySQL DB for POST Method APIs targets blind SQL injection vulnerabilities where no direct error messages are returned, but the database response time can be manipulated. Attackers inject SQL queries with specific delays, such as `SLEEP()` or `BENCHMARK()`, to cause the server to wait for a set amount of time before responding. By measuring the delay, the attacker can infer information about the database or application logic, allowing them to craft more targeted attacks. This method is useful for identifying vulnerabilities in scenarios where traditional SQL injection testing is ineffective due to lack of visible error feedback."
  impact: "The impact of the Time-Based SQL Injection Test for MySQL DB for POST Method APIs can be severe, as it allows attackers to extract sensitive database information without triggering visible errors. By leveraging response time delays, attackers can infer database structure, access control mechanisms, or sensitive data. This can lead to unauthorized access, data leakage, or further exploitation. Without proper defenses, such as input validation and the use of parameterized queries, this vulnerability can expose critical system flaws and result in significant security breaches."
  category:
    name: NO_AUTH
    shortName: Broken Authentication
    displayName: Broken User Authentication (BUA)
  subCategory: TIME_BASED_MYSQLI_POST
  severity: MEDIUM
  tags:
    - Business logic
    - OWASP top 10
    - HackerOne top 10
  references:
    - "https://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/"
    - "https://github.com/OWASP/API-Security/blob/master/editions/2023/en/0xa2-broken-authentication.md"
    - "https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html"
  cwe:
    - CWE-287
  cve:
    - CVE-2020-24008
    - CVE-2021-45901

attributes:
  nature: INTRUSIVE
  plan: FREE
  duration: FAST
compliance_standards:
  GDPR:
    - Article 32
    - Article 25
  HIPAA:
    - 45 CFR § 164.312(a)(2)(i)
    - 45 CFR § 164.308(a)(5)(ii)(C)
  SOC 2:
    - Logical and Physical Access Controls
    - User Authentication Mechanisms
  PCI DSS:
    - Requirement 8
    - Requirement 10
  ISO 27001:
    - A.9.2.2
    - A.9.4.3
  NIST 800-53:
    - IA-2
    - IA-5
  CSA CCM:
    - IAM-03
    - IAM-06
  CIS Controls:
    - IG1 Safeguard 5.1
    - IG1 Safeguard 5.4
    - IG2 Safeguard 16.11
  FedRAMP:
    - IA-2
    - IA-5
  NIST 800-171:
    - 3.5.1
    - 3.5.2
  FISMA:
    - IA-2
    - IA-5
  Cybersecurity Maturity Model Certification (CMMC):
    - IA.1.076
    - IA.2.078
api_selection_filters:
  method:
    eq: "POST"
  response_code:
    gte: 200
    lt: 300
  response_payload:
    length:
      gt: 0
    not_contains:
      - Error
      - Internal Server
      - Failed
      - Unauthorized
      - access denied
      - Forbidden
      - Method Not allowed
      - Gateway timeout
      - request timeout
      - server error
      - server busy
      - authentication error
      - authorization error
      - validation error
      - Permission Denied
      - invalid token
      - token expired
      - session expired
      - session timeout
      - unexpected error
      - unable to process request
      - bad request
      - service unavailable
      - account is locked
      - account is blocked
      - multiple failed attempts

  request_payload:
    for_one:
      key:
        regex: ".*"
        extract: userKey
      value:
        extract: userVal
wordLists:
  timeBasedPayloads:
    - "' OR IF(1=1, SLEEP(5), 0) -- -"
    - "' OR IF(1=1, BENCHMARK(10000000, SHA1('test')), 0) -- -"
    - "' OR IF((SELECT COUNT(*) FROM users) > 10, SLEEP(5), 0) -- -"
    - "' OR (SELECT IF(1=1, SLEEP(5), 0)) -- -"
execute:
  type: multiple
  requests:
    - req:
        - add_header:
            dummyKey: dummyVal
        - validate:
            response_code:
              gte: 200
              lt: 300
            response_payload:
              length:
                gt: 0
              not_contains:
                - Error
                - Internal Server
                - Failed
                - Unauthorized
                - access denied
                - Forbidden
                - Method Not allowed
                - Gateway timeout
                - request timeout
                - server error
                - server busy
                - authentication error
                - authorization error
                - validation error
                - Permission Denied
                - invalid token
                - token expired
                - session expired
                - session timeout
                - unexpected error
                - unable to process request
                - bad request
                - service unavailable
                - account is locked
                - account is blocked
                - multiple failed attempts
                - Attention Required!
                - CloudFlare
                - Sorry, you have been blocked
                - " OR "
        - success: x2
        - failure: exit
    - req:
        - modify_body_param:
            userKey: ${userVal}${timeBasedPayloads}
        - validate:
            response_code:
              eq: 429
validate:
  and:
    - compare_greater:
        - ${x2.response.stats.median_response_time}
        - 5001
    - compare_greater:
        - ${x2.response.stats.median_response_time}
        - ${x1.response.stats.median_response_time} * 5
